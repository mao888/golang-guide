## 练习 14.7：

- a）在练习 5.4 的 for_loop.go 中，有一个常见的 for 循环打印数字。在函数 tel() 中实现一个 for 循环，用协程开始这个函数并在其中给通道发送数字。main() 线程从通道中获取并打印。不要使用 time.Sleep() 来同步：goroutine_panic.go
```go
// 练习 5.4
package main

import "fmt"

func main() {
	// 1:
	for i := 0; i < 15; i++ {
		fmt.Printf("The counter is at %d\n", i)
	}
	// 2:
	i := 0
START:
	fmt.Printf("The counter is at %d\n", i)
	i++
	if i < 15 {
		goto START
	}
}
```
- b）也许你的方案有效，但可能会引发运行时的 panic()：throw:all goroutines are asleep-deadlock! 为什么会这样？你如何解决这个问题？goroutine_close.go

- c）解决 a）的另外一种方式：使用一个额外的通道传递给协程，然后在结束的时候随便放点什么进去。main() 线程检查是否有数据发送给了这个通道，如果有就停止：goroutine_select.go
